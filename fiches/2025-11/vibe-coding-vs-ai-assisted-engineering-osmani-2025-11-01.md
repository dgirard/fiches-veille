# vibe-coding-vs-ai-assisted-engineering-osmani-2025-11-01

## Veille
Vibe coding vs AI-assisted engineering - Addy Osmani - Software development - Engineering principles - LinkedIn

## Titre Article
Vibe-coding is not the same as AI-Assisted engineering.

## Date
2025-11-01

## URL
https://www.linkedin.com/posts/addyosmani_ai-programming-softwareengineering-activity-7368168236628013056-y20E

## Keywords
ai, programming, softwareengineering, vibe coding, AI-assisted engineering, software development, prototypes, MVPs, test-driven development, code reviews, engineering principles, force multiplier, human engineer control, scalability, maintainability, technical debt

## Authors
Addy Osmani

## Pense-betes
- **Distinction cruciale** : "vibe coding" ≠ "AI-assisted engineering"
- **Vibe Coding** : high-level prompting, creative flow, rapid experimentation, ideal pour prototypes/MVPs/learning/"throwaway weekend projects", moins rigorous review
- **AI-Assisted Engineering** : methodical AI integration dans mature SDLC, AI = "force multiplier" pour boilerplate/tests, human engineer controls architecture/review, ensures secure/scalable/maintainable
- **FAANG team** : **30% increase development speed** via disciplined augmentation (Reddit post cited)
- **Risks de conflation** : misrepresents skill/rigor d'engineering, gives newcomers false impression peuvent achieve production-ready via prompting alone
- **Best Practices** : start solid design, rigorous human review AI code, treat AI comme powerful tool not replacement
- **AI comme junior dev** : "helpful, but never unsupervised"
- **Verification burden** : significant oversight required prevent technical debt, security vulnerabilities, maintainability issues
- **Technical autonomy now** : understanding *when*, *what*, *why* to code, not just *how*

## RésuméDe400mots

Addy Osmani's LinkedIn post, titled "Vibe-coding is not the same as AI-Assisted engineering," addresses **critical semantic distinction** dans evolving landscape de software development. Osmani argues que conflating "vibe coding" avec professional "AI-assisted engineering" risks **devaluing engineering discipline** et providing newcomers avec incomplete picture de what it takes build robust, production-ready software.

**Defining Vibe Coding**

Il defines **"vibe coding"** comme highly creative, free-flowing approach où developers engage avec AI à travers high-level prompting, often accepting suggestions sans deep review. Cette method prioritizes speed et iterative experimentation, making ideal pour generating prototypes, Minimum Viable Products (MVPs), learning exercises, ou **"throwaway weekend projects"**. It's powerful way pour build intuition et flatten learning curve pour beginners, focusing sur exploration rather than correctness et maintainability essential pour professional applications.

**AI-Assisted Engineering : Disciplined Approach**

En stark contrast, **"AI-assisted engineering"** presented comme methodical integration de AI within mature software development lifecycle. Here, AI functions comme **"force multiplier"**, assisting engineers avec tasks comme generating boilerplate code ou drafting initial test cases. Crucially, **human engineer retains full control et responsibility** pour architecture, meticulously reviewing et understanding every line de AI-generated code. Cette approach ensures final product est secure, scalable, et maintainable, augmenting existing solid processes rather que replacing them. Reported **30% increase in development speed** dans FAANG team, cited dans Reddit post sparking discussion, attributed à cette disciplined augmentation, not abandonment d'engineering principles.

**Risks et Misrepresentation**

Osmani warns que **labeling disciplined, AI-augmented workflows comme "vibe coding" misrepresents skill et rigor** involved dans professional engineering. Pour new entrants au field, **fosters dangerous illusion** qu'on peut simply prompt way à viable product sans foundational understanding de code ou engineering fundamentals.

**Key Takeaways et Best Practices**

Key takeaways depuis post et supporting comments reinforce message : **always start solid design**, subject all AI-generated code à rigorous human review, et treat AI comme incredibly powerful tool dans engineering toolkit, **not magic wand**. Comme one commenter aptly put it, **"Use AI like junior dev: helpful, but never unsupervised."** **Verification burden** pour AI-generated code est significant, requiring careful oversight prevent technical debt, security vulnerabilities, et maintainability issues.

**Redefined Technical Autonomy**

Ultimately, post advocates pour **balanced, informed approach** à AI dans software development, où human expertise et established engineering practices remain paramount, leveraging AI enhance productivity within structured, responsible framework. True **technical autonomy now involves understanding *when*, *what*, et *why* to code**, avec human element d'organizational et human architecture remaining paramount, plutôt que just *how* to code.
